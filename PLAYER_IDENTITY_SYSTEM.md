## Player Identity System

A robust player name resolution system that handles variations, typos, and ambiguous matches across all data sources (KTC, Sleeper, user input).

## Problem Solved

**Before:**
```typescript
// Different sources, different names
ktc_value = { name: "Patrick Mahomes II", value: 10000 }
sleeper_roster = { name: "Patrick Mahomes", player_id: "4866" }
user_input = "Pat Mahomes"

// Which player is this? Manual matching required!
```

**After:**
```typescript
// All resolve to same canonical player_id
const result = await resolvePlayerId({ name: "Pat Mahomes", position: "QB" });
// → { success: true, player_id: "uuid-123", match_type: "alias" }

// Never store names, always store player_id
```

## Architecture

### 1. Player Aliases Table

Stores all known name variations for each player:

```sql
CREATE TABLE player_aliases (
  id uuid PRIMARY KEY,
  player_id uuid REFERENCES nfl_players(id),  -- Canonical player
  alias text NOT NULL,                         -- Original alias
  alias_normalized text NOT NULL UNIQUE,       -- Normalized for matching
  source text NOT NULL,                        -- sleeper, ktc, user, admin, auto
  created_at timestamptz,
  created_by uuid                              -- User who created (for manual)
);
```

**Sources:**
- `sleeper` - Auto-generated during Sleeper sync
- `ktc` - Created during KTC value imports
- `user` - Submitted by users
- `admin` - Added by administrators
- `auto` - Generated by system

**Examples:**
```typescript
// For Patrick Mahomes (player_id: abc-123)
[
  { alias: "Patrick Mahomes", alias_normalized: "patrickmahomes", source: "sleeper" },
  { alias: "Pat Mahomes", alias_normalized: "patmahomes", source: "user" },
  { alias: "P. Mahomes", alias_normalized: "pmahomes", source: "ktc" },
  { alias: "Mahomes, Patrick", alias_normalized: "mahomespatrick", source: "auto" },
  { alias: "Patrick Mahomes II", alias_normalized: "patrickmahomes", source: "sleeper" }
]
```

### 2. Name Normalization

Consistent normalization rules across all sources:

```typescript
import { normalizeName } from '@/lib/players/normalizeName';

normalizeName("Patrick Mahomes II")  // → "patrickmahomes"
normalizeName("D.J. Moore")          // → "djmoore"
normalizeName("A.J. Brown")          // → "ajbrown"
normalizeName("Gabe Davis Jr.")      // → "gabedavis"
normalizeName("Michael Carter")      // → "michaelcarter"
```

**Rules:**
1. Convert to lowercase
2. Remove punctuation (periods, commas, apostrophes, hyphens)
3. Collapse multiple spaces to single space
4. Remove suffixes (Jr, Sr, II, III, IV, V)
5. Convert dot variants (D.J. → dj)
6. Keep only letters and numbers
7. Remove all spaces (final step)

### 3. Universal Resolver

Resolves player names to canonical player_id with fallback logic:

```typescript
import { resolvePlayerId } from '@/lib/players/resolvePlayerId';

// Simple resolve
const result = await resolvePlayerId({
  name: "Pat Mahomes",
  position: "QB"  // optional but improves accuracy
});

if (result.success) {
  console.log("Resolved to:", result.player_id);
  console.log("Match type:", result.match.match_type);  // exact, alias, fuzzy
  console.log("Match score:", result.match.match_score);  // 0-100
} else {
  console.log("Suggestions:", result.suggestions);  // Top 5 matches
  console.log("Quarantined:", result.quarantined);  // Auto-quarantine?
}
```

**Resolution Order:**

1. **Exact Match** (100 points)
   - Search `nfl_players.search_name` for exact normalized match
   - Fastest lookup, O(1) via index

2. **Alias Match** (95 points)
   - Search `player_aliases.alias_normalized` for exact match
   - Handles known variations instantly

3. **Fuzzy Match** (70-90 points)
   - Token overlap scoring
   - Position bonus (+20 if position matches)
   - Team bonus (+10 if team matches)
   - Returns top 5 suggestions

4. **Quarantine** (if autoQuarantine: true)
   - Creates `unresolved_entities` record
   - Stores suggestions for admin review
   - Prevents silent data corruption

**Match Examples:**

```typescript
// Exact match
resolvePlayerId({ name: "Patrick Mahomes", position: "QB" })
// → { success: true, match_type: "exact", score: 100 }

// Alias match
resolvePlayerId({ name: "Pat Mahomes", position: "QB" })
// → { success: true, match_type: "alias", score: 95 }

// Fuzzy match (high confidence)
resolvePlayerId({ name: "Patrick Mahoms", position: "QB" })  // typo!
// → { success: true, match_type: "fuzzy", score: 88 }

// Ambiguous (multiple Michael Carters)
resolvePlayerId({ name: "Michael Carter" })
// → { success: false, suggestions: [
//     { name: "Michael Carter", position: "RB", team: "ARI", score: 85 },
//     { name: "Michael Carter", position: "CB", team: "NYJ", score: 85 }
//   ]}

// Add position to disambiguate
resolvePlayerId({ name: "Michael Carter", position: "RB" })
// → { success: true, match_type: "fuzzy", score: 105 }  // position bonus!
```

### 4. Automatic Alias Seeding

During Sleeper sync, aliases are auto-generated for each player:

```typescript
// In syncSleeperPlayers()
for (const player of sleeperPlayers) {
  // 1. Upsert player to nfl_players
  const playerId = await upsertPlayer(player);

  // 2. Generate alias variations
  const aliases = generateAliases(
    player.full_name,      // "Patrick Mahomes"
    player.first_name,     // "Patrick"
    player.last_name       // "Mahomes"
  );

  // 3. Seed aliases
  // → "Patrick Mahomes"
  // → "Mahomes, Patrick"
  // → "Patrick M"
  // → "P. Mahomes"
  // → "PatrickMahomes" (no space)
  for (const alias of aliases) {
    await addPlayerAlias(playerId, alias, 'sleeper');
  }
}
```

**Result:** Every Sleeper sync populates 5-10 aliases per player automatically.

### 5. Unresolved Entities Quarantine

When resolver can't confidently match, entities go to quarantine:

```sql
CREATE TABLE unresolved_entities (
  id uuid PRIMARY KEY,
  raw_name text NOT NULL,                -- Original problematic name
  player_position text,                  -- Position hint if available
  team text,                             -- Team hint if available
  source text NOT NULL,                  -- ktc, sleeper, user, trade_input
  status text DEFAULT 'open',            -- open, resolved, ignored
  resolved_player_id uuid,               -- Player if manually resolved
  suggestions jsonb,                     -- Top fuzzy match suggestions
  metadata jsonb,                        -- Additional context
  created_at timestamptz,
  resolved_at timestamptz,
  resolved_by uuid                       -- User who resolved
);
```

**Flow:**

```typescript
// Auto-quarantine on import
const result = await resolvePlayerId({
  name: "Pattrick Mahommes",  // Bad typo!
  position: "QB",
  source: "ktc",
  autoQuarantine: true
});

if (!result.success && result.quarantined) {
  console.log("Quarantined for review:", result.quarantine_id);
  console.log("Suggestions stored:", result.suggestions);
}

// Admin resolves later
await resolveQuarantinedEntity(
  result.quarantine_id,
  "abc-123",  // Correct player_id
  true        // Create alias for future
);
```

**Benefits:**
- No silent data corruption
- Admin review queue
- Learning system (creates aliases)
- Audit trail

## Usage Patterns

### Pattern 1: KTC Value Import

```typescript
import { resolvePlayerId } from '@/lib/players/resolvePlayerId';

async function importKTCValues(ktcData: any[]) {
  for (const row of ktcData) {
    // Resolve player
    const result = await resolvePlayerId({
      name: row.player_name,
      position: row.position,
      source: 'ktc',
      autoQuarantine: true  // Quarantine unknowns
    });

    if (!result.success) {
      console.warn(`Skipped: ${row.player_name} (quarantined)`);
      continue;
    }

    // Store using player_id (never raw name!)
    await supabase.from('ktc_value_snapshots').insert({
      player_id: result.player_id,  // ← Canonical ID
      ktc_value: row.value,
      format: row.format,
      captured_at: new Date()
    });
  }
}
```

### Pattern 2: Sleeper Roster Import

```typescript
import { resolvePlayerId } from '@/lib/players/resolvePlayerId';

async function importSleeperRoster(leagueId: string) {
  const rosters = await fetchSleeperRosters(leagueId);

  for (const roster of rosters) {
    for (const playerSleeperIdconst player = await getSleeperPlayerData(playerId);

      // Resolve by external ID first
      const result = await resolvePlayerId({
        name: player.full_name,
        position: player.position,
        team: player.team,
        source: 'sleeper'
      });

      if (!result.success) {
        console.error(`Failed to resolve: ${player.full_name}`);
        continue;
      }

      // Store roster entry
      await supabase.from('league_rosters').insert({
        league_id: leagueId,
        roster_id: roster.roster_id,
        player_id: result.player_id  // ← Canonical ID
      });
    }
  }
}
```

### Pattern 3: User Trade Input

```typescript
import { resolvePlayerId } from '@/lib/players/resolvePlayerId';

async function handleTradeInput(playerName: string, position?: string) {
  // Resolve with user context
  const result = await resolvePlayerId({
    name: playerName,
    position,
    source: 'trade_input',
    fuzzyThreshold: 0.6,  // More lenient for user typos
    autoQuarantine: true
  });

  if (!result.success) {
    if (result.suggestions.length > 0) {
      // Show suggestions to user
      return {
        type: 'suggestions',
        suggestions: result.suggestions.map(s => ({
          name: s.full_name,
          position: s.player_position,
          team: s.team
        }))
      };
    } else {
      return { type: 'error', message: 'Player not found' };
    }
  }

  // Success - use player_id
  return {
    type: 'success',
    player_id: result.player_id,
    player_name: result.match.full_name
  };
}
```

### Pattern 4: Batch Resolution

```typescript
import { resolveBatch } from '@/lib/players/resolvePlayerId';

const players = [
  { name: "Patrick Mahomes", position: "QB" },
  { name: "Tyreek Hill", position: "WR" },
  { name: "Travis Kelce", position: "TE" }
];

const results = await resolveBatch(players, { source: 'user' });

for (const [name, result] of results) {
  if (result.success) {
    console.log(`${name} → ${result.player_id}`);
  } else {
    console.error(`${name} failed:`, result.error);
  }
}
```

## Admin UI

### Access

Navigate to `/admin/aliases` (add route to your app):

```typescript
// In App.tsx or router
import { PlayerAliasManager } from '@/components/PlayerAliasManager';

<Route path="/admin/aliases" element={<PlayerAliasManager />} />
```

### Features

**1. Player Search**
- Search any player by name
- View player details
- Select player to manage aliases

**2. Alias Management**
- View all aliases for a player
- Add manual aliases
- Delete invalid aliases
- See alias source (sleeper, ktc, user, admin)

**3. Quarantine Queue**
- View all unresolved entities
- See suggestions with scores
- Match to correct player
- Optionally create alias
- Ignore false positives

**4. Resolver Tester**
- Test name variations
- See match type and score
- Debug resolution logic
- Validate before import

### Workflow

**Resolve Quarantined Entity:**

1. Go to "Quarantine" tab
2. Review unresolved entity
3. Check suggestions
4. Click "Match + Alias" to:
   - Link entity to player
   - Create alias for future
   - Mark as resolved
5. Or click "Match Only" to:
   - Link entity to player
   - Don't create alias
   - Mark as resolved
6. Or click ignore (X) to skip

**Add Manual Alias:**

1. Search for player
2. Click player to select
3. Go to "Manage Aliases" tab
4. Enter alias in input
5. Click "Add"
6. Alias is normalized and stored

**Test Resolver:**

1. Go to "Test Resolver" tab
2. Enter player name
3. Optionally add position/team
4. Click "Test Resolver"
5. See result:
   - Success: Shows matched player, type, score
   - Failure: Shows error and suggestions

## API Reference

### resolvePlayerId

Resolve player name to canonical player_id:

```typescript
interface ResolveOptions {
  name: string;               // Player name
  position?: string;          // QB, RB, WR, TE, etc.
  team?: string;              // Team code (optional)
  source?: string;            // Data source
  fuzzyThreshold?: number;    // 0-1, default 0.7
  maxSuggestions?: number;    // Default 5
  autoQuarantine?: boolean;   // Default true
}

interface ResolveResult {
  success: boolean;
  player_id?: string;
  match?: PlayerMatch;
  suggestions?: PlayerMatch[];
  quarantined?: boolean;
  quarantine_id?: string;
  error?: string;
}

const result = await resolvePlayerId(options);
```

### addManualAlias

Add manual alias for a player:

```typescript
const success = await addManualAlias(
  playerId,     // uuid
  alias,        // string
  source        // 'user' | 'admin' | 'auto'
);
```

### resolveBatch

Batch resolve multiple players:

```typescript
const results = await resolveBatch(
  [{ name: "...", position: "..." }, ...],
  options?
);
// Returns Map<string, ResolveResult>
```

### resolveQuarantinedEntity

Manually resolve quarantined entity:

```typescript
const success = await resolveQuarantinedEntity(
  entityId,      // uuid
  playerId,      // uuid
  createAlias    // boolean - create alias for future?
);
```

### ignoreQuarantinedEntity

Mark quarantined entity as ignored:

```typescript
const success = await ignoreQuarantinedEntity(entityId);
```

### getPlayerAliases

Get all aliases for a player:

```typescript
const aliases = await getPlayerAliases(playerId);
// Returns Array<{ id, alias, alias_normalized, source, created_at }>
```

### getUnresolvedEntities

Get quarantine queue:

```typescript
const entities = await getUnresolvedEntities(
  status,  // 'open' | 'resolved' | 'ignored'
  limit    // number, default 100
);
```

## Database Functions

### SQL: add_player_alias

```sql
SELECT add_player_alias(
  p_player_id := 'uuid',
  p_alias := 'Pat Mahomes',
  p_alias_normalized := 'patmahomes',
  p_source := 'admin'
);
```

### SQL: resolve_unresolved_entity

```sql
SELECT resolve_unresolved_entity(
  p_entity_id := 'uuid',
  p_player_id := 'uuid',
  p_create_alias := true
);
```

### SQL: search_aliases

```sql
SELECT * FROM search_aliases('mahomes', 10);
-- Returns matching players with alias info
```

## Best Practices

### 1. Always Resolve Before Storing

**Bad:**
```typescript
// ❌ Storing raw name
await supabase.from('trades').insert({
  player_name: "Pat Mahomes",  // Name can change!
  value: 10000
});
```

**Good:**
```typescript
// ✅ Resolve to player_id first
const result = await resolvePlayerId({ name: "Pat Mahomes", position: "QB" });
await supabase.from('trades').insert({
  player_id: result.player_id,  // Canonical ID
  value: 10000
});
```

### 2. Always Provide Position When Available

```typescript
// ❌ Ambiguous
resolvePlayerId({ name: "Michael Carter" })
// Could match Michael Carter (RB) OR Michael Carter (CB)

// ✅ Specific
resolvePlayerId({ name: "Michael Carter", position: "RB" })
// Unambiguous
```

### 3. Use Auto-Quarantine for Imports

```typescript
// ✅ Safe import with quarantine
const result = await resolvePlayerId({
  name: ktcRow.player_name,
  source: 'ktc',
  autoQuarantine: true  // Don't corrupt data silently
});

if (!result.success) {
  console.warn(`Quarantined: ${ktcRow.player_name}`);
  continue;  // Skip this row
}

// Proceed with import...
```

### 4. Review Quarantine Regularly

Set up admin routine:
1. Daily: Check quarantine queue
2. Resolve/ignore entities
3. Monitor quarantine stats

```typescript
const stats = await supabase.rpc('get_unresolved_stats');
console.log(stats);
// { total: 42, open: 15, resolved: 20, ignored: 7 }
```

### 5. Create Aliases for Common Variations

When you notice repeated failures for a name variation:

```typescript
// Add permanent alias
await addManualAlias(
  playerId,
  "Pat Mahomes",  // Common variation
  'admin'
);
```

## Migration Path

### Step 1: Deploy System

- ✅ Tables created (`player_aliases`, `unresolved_entities`)
- ✅ Functions deployed (`resolvePlayerId`, etc.)
- ✅ Admin UI available

### Step 2: Populate Aliases

Run initial Sleeper sync:

```bash
curl "https://[project].supabase.co/functions/v1/sync-sleeper-players?secret=CRON_SECRET"
```

This seeds ~5-10 aliases per player automatically.

### Step 3: Refactor Imports

Update KTC sync, roster imports, etc. to use resolver:

```typescript
// Before
const player = players.find(p => p.name === ktcRow.player_name);

// After
const result = await resolvePlayerId({ name: ktcRow.player_name, source: 'ktc' });
const playerId = result.player_id;
```

### Step 4: Clean Quarantine

Review and resolve quarantined entities via admin UI.

### Step 5: Monitor

Watch quarantine stats and add aliases as needed.

## Monitoring

### Quarantine Stats

```typescript
const stats = await supabase.rpc('get_unresolved_stats');
// { total: 42, open: 15, resolved: 20, ignored: 7, by_source: { ktc: 10, user: 5 } }
```

### Alias Coverage

```sql
SELECT
  COUNT(DISTINCT player_id) as players_with_aliases,
  COUNT(*) as total_aliases,
  AVG(alias_count) as avg_aliases_per_player
FROM (
  SELECT player_id, COUNT(*) as alias_count
  FROM player_aliases
  GROUP BY player_id
) subquery;
```

### Resolution Success Rate

```sql
-- Track resolution attempts vs quarantine
SELECT
  source,
  COUNT(*) as total_attempts,
  SUM(CASE WHEN status = 'open' THEN 1 ELSE 0 END) as failed,
  ROUND(100.0 * SUM(CASE WHEN status != 'open' THEN 1 ELSE 0 END) / COUNT(*), 2) as success_rate
FROM unresolved_entities
GROUP BY source;
```

## Summary

The Player Identity System provides:

✅ **Robust Resolution** - Handles typos, variations, and ambiguous names

✅ **Automatic Aliases** - Sleeper sync generates 5-10 aliases per player

✅ **Fuzzy Matching** - Token overlap scoring with position/team bonuses

✅ **Quarantine Queue** - Prevents silent data corruption

✅ **Admin UI** - Easy alias management and entity resolution

✅ **Audit Trail** - Track all resolutions and changes

✅ **Zero Guessing** - Never silently corrupts data with wrong matches

✅ **Learning System** - Creates aliases from resolved entities

This is the foundation real fantasy platforms use to maintain data integrity across multiple sources. Your platform now has enterprise-grade player name resolution!
